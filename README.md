Poniard
================

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<p align="center">
<img src="https://raw.githubusercontent.com/rxavier/poniard/main/logo.png" alt="Poniard logo" title="Poniard" width="50%"/>
</p>

## Introduction

> A poniard /ˈpɒnjərd/ or poignard (Fr.) is a long, lightweight
> thrusting knife ([Wikipedia](https://en.wikipedia.org/wiki/Poignard)).

Poniard is a scikit-learn companion library that streamlines the process
of fitting different machine learning models and comparing them.

It can be used to provide quick answers to questions like these: \* What
is the reasonable range of scores for this task? \* Is a simple and
explainable linear model enough or should I work with forests and
gradient boosters? \* Are the features good enough as is or should I
work on feature engineering? \* How much can hyperparemeter tuning
improve metrics? \* Do I need to work on a custom preprocessing
strategy?

This is not meant to be end to end solution, and you definitely should
keep on working on your models after you are done with Poniard.

The core functionality has been tested to work on Python 3.7 through
3.10 on Linux systems, and from 3.8 to 3.10 on macOS.

## Installation

Stable version:

``` bash
pip install poniard
```

Dev version with most up to date changes:

``` bash
pip install git+https://github.com/rxavier/poniard.git@develop#egg=poniard
```

## Documentation

Check the full [Quarto docs](https://rxavier.github.io/poniard),
including guides and API reference.

## Usage/features

### Basics

The API was designed with tabular tasks in mind, but it should also work
with time series tasks provided an appropiate cross validation strategy
is used (don’t shuffle!)

The usual Poniard flow is: 1. Define some estimators. 2. Define some
metrics. 3. Define a cross validation strategy. 4. Fit everything. 5.
Print the results.

Poniard provides sane defaults for 1, 2 and 3, so in most cases you can
just do…

``` python
from poniard import PoniardClassifier
from sklearn.datasets import load_breast_cancer
```

``` python
X, y = load_breast_cancer(return_X_y=True, as_frame=True)
pnd = PoniardClassifier(random_state=0)
pnd.setup(X, y)
pnd.fit()
```

    Target info
    -----------
    Type: binary
    Shape: (569,)
    Unique values: 2

    Main metric
    -----------
    roc_auc

    Thresholds
    ----------
    Minimum unique values to consider a feature numeric: 56
    Minimum unique values to consider a categorical high cardinality: 20

    Inferred feature types
    ----------------------

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>numeric</th>
      <th>categorical_high</th>
      <th>categorical_low</th>
      <th>datetime</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>mean radius</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>1</th>
      <td>mean texture</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>2</th>
      <td>mean perimeter</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>3</th>
      <td>mean area</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>4</th>
      <td>mean smoothness</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>5</th>
      <td>mean compactness</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>6</th>
      <td>mean concavity</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>7</th>
      <td>mean concave points</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>8</th>
      <td>mean symmetry</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>9</th>
      <td>mean fractal dimension</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>10</th>
      <td>radius error</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>11</th>
      <td>texture error</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>12</th>
      <td>perimeter error</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>13</th>
      <td>area error</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>14</th>
      <td>smoothness error</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>15</th>
      <td>compactness error</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>16</th>
      <td>concavity error</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>17</th>
      <td>concave points error</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>18</th>
      <td>symmetry error</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>19</th>
      <td>fractal dimension error</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>20</th>
      <td>worst radius</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>21</th>
      <td>worst texture</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>22</th>
      <td>worst perimeter</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>23</th>
      <td>worst area</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>24</th>
      <td>worst smoothness</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>25</th>
      <td>worst compactness</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>26</th>
      <td>worst concavity</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>27</th>
      <td>worst concave points</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>28</th>
      <td>worst symmetry</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>29</th>
      <td>worst fractal dimension</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
  </tbody>
</table>

      0%|          | 0/9 [00:00<?, ?it/s]

    PoniardClassifier(estimators=None, metrics=['roc_auc', 'accuracy', 'precision', 'recall', 'f1'],
        preprocess=True, scaler=standard, numeric_imputer=simple,
        custom_preprocessor=None, numeric_threshold=56,
        cardinality_threshold=20, cv=StratifiedKFold(n_splits=5, random_state=0, shuffle=True), verbose=0,
        random_state=0, n_jobs=None, plugins=None,
        plot_options=PoniardPlotFactory())
                

… and get a nice table showing the average of each metric in all folds
for every model, including fit and score times (thanks, scikit-learn
`cross_validate` function!)

``` python
pnd.get_results()
```

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>test_roc_auc</th>
      <th>test_accuracy</th>
      <th>test_precision</th>
      <th>test_recall</th>
      <th>test_f1</th>
      <th>fit_time</th>
      <th>score_time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>LogisticRegression</th>
      <td>0.995456</td>
      <td>0.978916</td>
      <td>0.975411</td>
      <td>0.991549</td>
      <td>0.983351</td>
      <td>0.012594</td>
      <td>0.004843</td>
    </tr>
    <tr>
      <th>SVC</th>
      <td>0.994139</td>
      <td>0.975408</td>
      <td>0.975111</td>
      <td>0.985955</td>
      <td>0.980477</td>
      <td>0.012787</td>
      <td>0.004670</td>
    </tr>
    <tr>
      <th>HistGradientBoostingClassifier</th>
      <td>0.994128</td>
      <td>0.970129</td>
      <td>0.967263</td>
      <td>0.985955</td>
      <td>0.976433</td>
      <td>0.629406</td>
      <td>0.020246</td>
    </tr>
    <tr>
      <th>XGBClassifier</th>
      <td>0.994123</td>
      <td>0.970129</td>
      <td>0.967554</td>
      <td>0.985915</td>
      <td>0.976469</td>
      <td>0.049646</td>
      <td>0.004199</td>
    </tr>
    <tr>
      <th>RandomForestClassifier</th>
      <td>0.992264</td>
      <td>0.964881</td>
      <td>0.964647</td>
      <td>0.980282</td>
      <td>0.972192</td>
      <td>0.072604</td>
      <td>0.008286</td>
    </tr>
    <tr>
      <th>GaussianNB</th>
      <td>0.988730</td>
      <td>0.929700</td>
      <td>0.940993</td>
      <td>0.949413</td>
      <td>0.944300</td>
      <td>0.005015</td>
      <td>0.006831</td>
    </tr>
    <tr>
      <th>KNeighborsClassifier</th>
      <td>0.980610</td>
      <td>0.964881</td>
      <td>0.955018</td>
      <td>0.991628</td>
      <td>0.972746</td>
      <td>0.002585</td>
      <td>0.013569</td>
    </tr>
    <tr>
      <th>DecisionTreeClassifier</th>
      <td>0.920983</td>
      <td>0.926223</td>
      <td>0.941672</td>
      <td>0.941080</td>
      <td>0.941054</td>
      <td>0.005604</td>
      <td>0.002427</td>
    </tr>
    <tr>
      <th>DummyClassifier</th>
      <td>0.500000</td>
      <td>0.627418</td>
      <td>0.627418</td>
      <td>1.000000</td>
      <td>0.771052</td>
      <td>0.001752</td>
      <td>0.002329</td>
    </tr>
  </tbody>
</table>

Alternatively, you can also get a nice plot of your different metrics by
using the `PoniardBaseEstimator.plot.metrics` method.

### Type inference

Poniard uses some basic heuristics to infer the data types.

Float and integer columns are defined as numeric if the number of unique
values is greater than indicated by the `categorical_threshold`
parameter.

String/object/categorical columns are assumed to be categorical.

Datetime features are processed separately with a custom encoder.

For categorical features, high and low cardinality is defined by the
`cardinality_threshold` parameter. Only low cardinality categorical
features are one-hot encoded.

### Ensembles

Poniard makes it easy to combine various estimators in stacking or
voting ensembles. The base esimators can be selected according to their
performance (top-n) or chosen by their names.

Poniard also reports how similar the predictions of the estimators are,
so ensembles with different base estimators can be built. A basic
correlation table of the cross-validated predictions is built for
regression tasks, while [Cramér’s
V](https://en.wikipedia.org/wiki/Cram%C3%A9r%27s_V) is used for
classification.

By default, it computes this similarity of prediction errors instead of
the actual predictions; this helps in building ensembles with good
scoring estimators and uncorrelated errors, which in principle and
hopefully should lead to a “wisdom of crowds” kind of situation.

### Hyperparameter optimization

The
[`PoniardBaseEstimator.tune_estimator`](https://rxavier.github.io/poniard/estimators.core.html#poniardbaseestimator.tune_estimator)
method can be used to optimize the hyperparameters of a given estimator,
either by passing a grid of parameters or using the inbuilt ones
available for default estimators. The tuned estimator will be added to
the list of estimators and will be scored the next time
[`PoniardBaseEstimator.fit`](https://rxavier.github.io/poniard/estimators.core.html#poniardbaseestimator.fit)
is called.

``` python
pnd.tune_estimator("RandomForestClassifier", mode="random")
pnd.fit()  # This will only fit new estimators
pnd.get_results()
```

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>test_roc_auc</th>
      <th>test_accuracy</th>
      <th>test_precision</th>
      <th>test_recall</th>
      <th>test_f1</th>
      <th>fit_time</th>
      <th>score_time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>LogisticRegression</th>
      <td>0.995456</td>
      <td>0.978916</td>
      <td>0.975411</td>
      <td>0.991549</td>
      <td>0.983351</td>
      <td>0.012594</td>
      <td>0.004843</td>
    </tr>
    <tr>
      <th>SVC</th>
      <td>0.994139</td>
      <td>0.975408</td>
      <td>0.975111</td>
      <td>0.985955</td>
      <td>0.980477</td>
      <td>0.012787</td>
      <td>0.004670</td>
    </tr>
    <tr>
      <th>HistGradientBoostingClassifier</th>
      <td>0.994128</td>
      <td>0.970129</td>
      <td>0.967263</td>
      <td>0.985955</td>
      <td>0.976433</td>
      <td>0.629406</td>
      <td>0.020246</td>
    </tr>
    <tr>
      <th>XGBClassifier</th>
      <td>0.994123</td>
      <td>0.970129</td>
      <td>0.967554</td>
      <td>0.985915</td>
      <td>0.976469</td>
      <td>0.049646</td>
      <td>0.004199</td>
    </tr>
    <tr>
      <th>RandomForestClassifier_tuned</th>
      <td>0.992696</td>
      <td>0.959618</td>
      <td>0.961836</td>
      <td>0.974726</td>
      <td>0.968054</td>
      <td>0.071381</td>
      <td>0.008178</td>
    </tr>
    <tr>
      <th>RandomForestClassifier</th>
      <td>0.992264</td>
      <td>0.964881</td>
      <td>0.964647</td>
      <td>0.980282</td>
      <td>0.972192</td>
      <td>0.072604</td>
      <td>0.008286</td>
    </tr>
    <tr>
      <th>GaussianNB</th>
      <td>0.988730</td>
      <td>0.929700</td>
      <td>0.940993</td>
      <td>0.949413</td>
      <td>0.944300</td>
      <td>0.005015</td>
      <td>0.006831</td>
    </tr>
    <tr>
      <th>KNeighborsClassifier</th>
      <td>0.980610</td>
      <td>0.964881</td>
      <td>0.955018</td>
      <td>0.991628</td>
      <td>0.972746</td>
      <td>0.002585</td>
      <td>0.013569</td>
    </tr>
    <tr>
      <th>DecisionTreeClassifier</th>
      <td>0.920983</td>
      <td>0.926223</td>
      <td>0.941672</td>
      <td>0.941080</td>
      <td>0.941054</td>
      <td>0.005604</td>
      <td>0.002427</td>
    </tr>
    <tr>
      <th>DummyClassifier</th>
      <td>0.500000</td>
      <td>0.627418</td>
      <td>0.627418</td>
      <td>1.000000</td>
      <td>0.771052</td>
      <td>0.001752</td>
      <td>0.002329</td>
    </tr>
  </tbody>
</table>

### Plotting

The `plot` accessor provides several plotting methods based on the
attached Poniard estimator instance. These Plotly plots are based on a
default template, but can be modified by passing a different
[`PoniardPlotFactory`](https://rxavier.github.io/poniard/plot.plot_factory.html#poniardplotfactory)
to the Poniard `plot_options` argument.

### Plugin system

The `plugins` argument in Poniard estimators takes a plugin or list of
plugins that subclass
[`BasePlugin`](https://rxavier.github.io/poniard/plugins.core.html#baseplugin).
These plugins have access to the Poniard estimator instance and hook
onto different sections of the process, for example, on setup start, on
fit end, on remove estimator, etc.

This makes it easy for third parties to extend Poniard’s functionality.

Two plugins are baked into Poniard. 1. Weights and Biases: logs your
data, plots, runs wandb scikit-learn analysis, saves model artifacts,
etc. 2. Pandas Profiling: generates an HTML report of the features and
target. If the Weights and Biases plugin is present, also logs this
report to the wandb run.

The requirements for these plugins are not included in the base Poniard
dependencies, so you can safely ignore them if you don’t intend to use
them.

## Design philosophy

### Not another dependency

We try very hard to avoid cluttering the environment with stuff you
won’t use outside of this library. Poniard’s dependencies are:

1.  scikit-learn (duh)
2.  pandas
3.  XGBoost
4.  Plotly
5.  tqdm
6.  That’s it!

Apart from `tqdm` and possibly `Plotly`, all dependencies most likely
were going to be installed anyway, so Poniard’s added footprint should
be small.

### We don’t do that here (AutoML)

Poniard tries not to take control away from the user. As such, it is not
designed to perform 2 hours of feature engineering and selection, try
every model under the sun together with endless ensembles and select the
top performing model according to some metric.

Instead, it strives to abstract away some of the boilerplate code needed
to fit and compare a number of models and allows the user to decide what
to do with the results.

Poniard can be your first stab at a prediction problem, but it
definitely shouldn’t be your last one.

### Opinionated with a few exceptions

While some parameters can be modified to control how variable type
inference and preprocessing are performed, the API is designed to
prevent parameter proliferation.

### Cross validate all the things

Everything in Poniard is run with cross validation by default, and in
fact no relevant functionality can be used without cross validation.

### Use baselines

A dummy estimator is always included in model comparisons so you can
gauge whether your model is better than a dumb strategy.

### Fast TTFM (time to first model)

Preprocessing tries to ensure that your models run successfully without
significant data munging. By default, Poniard imputes missing data and
one-hot encodes or target encodes (depending on cardinality) inferred
categorical variables, which in most cases is enough for scikit-learn
algorithms to fit without complaints. Additionally, it scales numeric
data and drops features with a single unique value.

## Similar projects

Poniard is not a groundbreaking idea, and a number of libraries follow a
similar approach.

**[ATOM](https://github.com/tvdboom/ATOM)** is perhaps the most similar
library to Poniard, albeit with a different approach to the API.

**[LazyPredict](https://github.com/shankarpandala/lazypredict)** is
similar in that it runs multiple estimators and provides results for
various metrics. Unlike Poniard, by default it tries most scikit-learn
estimators, and is not based on cross validation.

**[PyCaret](https://github.com/pycaret/pycaret)** is a whole other beast
that includes model explainability, deployment, plotting, NLP, anomaly
detection, etc., which leads to a list of dependencies several times
larger than Poniard’s, and a more complicated API.
